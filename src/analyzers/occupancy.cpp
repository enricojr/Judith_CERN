#include "occupancy.h"

#include <cassert>
#include <sstream>
#include <math.h>

#include <TDirectory.h>
#include <TH2D.h>
#include <TH1D.h>

// Access to the device being analyzed and its sensors
#include "../mechanics/device.h"
#include "../mechanics/sensor.h"
// Access to the data stored in the event
#include "../storage/hit.h"
#include "../storage/cluster.h"
#include "../storage/plane.h"
#include "../storage/track.h"
#include "../storage/event.h"
// Some generic processors to calcualte typical event related things
#include "../processors/processors.h"
// This header defines all the cuts
#include "cuts.h"

namespace Analyzers {

void Occupancy::processEvent(const Storage::Event* event)
{
  assert(event && "Analyzer: can't process null events");

  // Throw an error for sensor / plane mismatch
  eventDeivceAgree(event);

  // Check if the event passes the cuts
  for (unsigned int ncut = 0; ncut < _numEventCuts; ncut++)
    if (!_eventCuts.at(ncut)->check(event)) return;

  for (unsigned int nplane = 0; nplane < event->getNumPlanes(); nplane++)
  {
    Storage::Plane* plane = event->getPlane(nplane);
    for (unsigned int nhit = 0; nhit < plane->getNumHits(); nhit++)
    {
      Storage::Hit* hit = plane->getHit(nhit);

      // Check if the hit passes the cuts
      bool pass = true;
      for (unsigned int ncut = 0; ncut < _numHitCuts; ncut++)
        if (!_hitCuts.at(ncut)->check(hit)) { pass = false; break; }
      if (!pass) continue;


      totalHitOccupancy++;
      _hitOcc.at(nplane)->Fill(hit->getPixX(), hit->getPixY());
    }

    for (unsigned int ncluster = 0; ncluster < plane->getNumClusters(); ncluster++)
    {
      Storage::Cluster* cluster = plane->getCluster(ncluster);

      // Check if the cluster passes the cuts
      bool pass = true;
      for (unsigned int ncut = 0; ncut < _numClusterCuts; ncut++)
        if (!_clusterCuts.at(ncut)->check(cluster)) { pass = false; break; }
      if (!pass) continue;


      _clusterOcc.at(nplane)->Fill(cluster->getPosX(), cluster->getPosY());
      //HP added debug ntuple
      _clusterNtuple.at(nplane)->Fill(cluster->getNumHits(),cluster->getPosX(),cluster->getPosY(),cluster->getValue(),plane->getNumClusters(),cluster->getTiming(),cluster->getMatchDistance());
    }
  }
}

void Occupancy::postProcessing()
{
  if (_postProcessed) return;

  // Generate the bounds of the 1D occupancy hist
  unsigned int totalHits = 0;
  unsigned int maxHits = 0;
  for (unsigned int nsens = 0; nsens < _device->getNumSensors(); nsens++)
  {
    Mechanics::Sensor* sensor = _device->getSensor(nsens);
    TH2D* occ = _hitOcc.at(nsens);

    for (unsigned int x = 0; x < sensor->getNumX(); x++)
    {
      for (unsigned int y = 0; y < sensor->getNumY(); y++)
      {
        const unsigned int numHits = occ->GetBinContent(x + 1, y + 1);
        totalHits += numHits;
        if (numHits > maxHits) maxHits = numHits;
      }
    }
  }

  TDirectory* plotDir = makeGetDirectory("Occupancy");

  std::stringstream name;
  std::stringstream title;

  name << "OccupancyDistribution";
  title << "Occupancy Distribution";

  _occDistribution = new TH1D(name.str().c_str(), title.str().c_str(),
                              100, 0, (double)maxHits / (double)totalHits);

  _occDistribution->SetDirectory(_dir);
  _occDistribution->GetXaxis()->SetTitle("Hits per trigger");
  _occDistribution->GetYaxis()->SetTitle("Pixels");
  _occDistribution->SetDirectory(plotDir);

  // Fill the occupancy distribution
  for (unsigned int nsens = 0; nsens < _device->getNumSensors(); nsens++)
  {
    Mechanics::Sensor* sensor = _device->getSensor(nsens);
    TH2D* occ = _hitOcc.at(nsens);

    for (unsigned int x = 0; x < sensor->getNumX(); x++)
    {
      for (unsigned int y = 0; y < sensor->getNumY(); y++)
      {
        const unsigned int numHits = occ->GetBinContent(x + 1, y + 1);
        _occDistribution->Fill((double)numHits / (double)totalHits);
      }
    }
  }

  _postProcessed = true;
}

TH1D* Occupancy::getOccDistribution()
{
  if (!_postProcessed)
    throw "Occupancy: requested plot needs to be generated by post-processing";
  return _occDistribution;
}

TH2D* Occupancy::getHitOcc(unsigned int nsensor)
{
  validSensor(nsensor);
  return _hitOcc.at(nsensor);
}

Occupancy::Occupancy(const Mechanics::Device* device,
                     TDirectory* dir,
                     const char* suffix) :
  // Base class is initialized here and manages directory / device
  SingleAnalyzer(device, dir, suffix),
  totalHitOccupancy(0)
{
  assert(device && "Analyzer: can't initialize with null device");

  // Makes or gets a directory called from inside _dir with this name
  TDirectory* plotDir = makeGetDirectory("Occupancy");

  std::stringstream name; // Build name strings for each histo
  std::stringstream title; // Build title strings for each histo

  // Generate a histogram for each sensor in the device
  for (unsigned int nsens = 0; nsens < _device->getNumSensors(); nsens++)
  {
    Mechanics::Sensor* sensor = _device->getSensor(nsens);

    name.str(""); title.str("");
    name << sensor->getName() << "HitOccupancy" << _nameSuffix;
    title << sensor->getName() << " Pixel Occupancy"
          << ";X pixel"
          << ";Y pixel"
          << ";Hits / pixel";
    TH2D* hist = new TH2D(name.str().c_str(), title.str().c_str(),
                          sensor->getNumX(), 0 - 0.5, sensor->getNumX() - 0.5,
                          sensor->getNumY(), 0 - 0.5, sensor->getNumY() - 0.5);
    hist->SetDirectory(plotDir);
    _hitOcc.push_back(hist);

    const double lowX = sensor->getOffX() - sensor->getPosSensitiveX() / 2.0;
    const double uppX = sensor->getOffX() + sensor->getPosSensitiveX() / 2.0;
    const double lowY = sensor->getOffY() - sensor->getPosSensitiveY() / 2.0;
    const double uppY = sensor->getOffY() + sensor->getPosSensitiveY() / 2.0;

    name.str(""); title.str("");
    name << sensor->getName() << "ClusterOccupancy" << _nameSuffix;
    title << sensor->getName() << " Cluster Occupancy"
          << ";X position [" << _device->getSpaceUnit() << "]"
          << ";Y position [" << _device->getSpaceUnit() << "]"
          << ";Clusters / pixel";
    TH2D* histClust = new TH2D(name.str().c_str(), title.str().c_str(),
                               sensor->getPosNumX(), lowX, uppX,
                               sensor->getPosNumY(), lowY, uppY);
    histClust->SetDirectory(plotDir);
    _clusterOcc.push_back(histClust);

    name.str(""); title.str("");
    name << sensor->getName() << "ClusterNtuple" << _nameSuffix;
    title << sensor->getName() << " Cluster Ntuple"
          << ";X position [" << _device->getSpaceUnit() << "]"
          << ";Y position [" << _device->getSpaceUnit() << "]"
          << ";Clusters / pixel";
    TNtuple* clusterNt = new TNtuple(name.str().c_str(), title.str().c_str(),
                               "hits:x:y:tot:nclus:time:dist");
    clusterNt->SetDirectory(plotDir);
    _clusterNtuple.push_back(clusterNt);
  }
}

}
